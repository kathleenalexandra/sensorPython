from __future__ import print_function


import struct

from binascii import hexlify

import pygatt

import logging

import math

import multiprocessing

import time


# clear the logfile at the beginning of the program

open("logfile.log", "w").close()


# make sure the pygatt logger is properly setup

logging.basicConfig(filename='logfile.log', filemode='w', format= '%(message)s', level=logging.INFO)

logging.getLogger('pygatt').setLevel(logging.DEBUG)


# from pygatt example

def handle_data(handle, value):

    """

    handle -- integer, characteristic read handle the data was received on

    value -- bytearray, the data returned in the notification

    """

    print("Received data: %s" % hexlify(value))


# for converting hex to signed int

def twos_complement(hexstr,bits):

        value = int(hexstr,16)

        if value & (1 << (bits-1)):

            value -= 1 << bits

        return value


# used to reorder the SensorTile data

list_swap_array = [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18]


# for interpoleting the SensorTile into a usable format

def convert_ST_data(input_split_list, orientation_output):

    input_split_list = [input_split_list[4].replace("value=0xb", "").replace("'", "")[2 * i:2 * i + 2] for i in range(20)]

    input_split_list = [input_split_list[i] for i in list_swap_array]

    for i in range(9, -1, -1):

        input_split_list[2 * i:2 * (i + 1)] = ["".join(input_split_list[2 * i:2 * (i + 1)])]

    input_split_list = [twos_complement(input_split_list[i], 16) for i in range(len(input_split_list))]

    orientation_output[0] = round(math.sqrt(input_split_list[1] ** 2 + input_split_list[2] ** 2 + input_split_list[3] ** 2), 2)

    orientation_output[1] = round(math.acos(input_split_list[3] / orientation_output[0]) * RADIAN, 2)

    orientation_output[2] = round(math.atan2(input_split_list[2], input_split_list[1]) * RADIAN, 2)

    return(orientation_output)


# for orientation calculations

RADIAN = 57.2957795


# REPLACE THIS STRING WITH THE MAC ADDRESS OF YOUR SENSOR TILE

YOUR_DEVICE_ADDRESS = "C0:83:47:30:5a:4d"


# Many devices, e.g. Fitbit, use random addressing - this is required to connect.

# (this is the equivalent of typing "-t random" in the gatttool cli)

ADDRESS_TYPE = pygatt.BLEAddressType.random


adapter = pygatt.GATTToolBackend()

motion_data_enabler_handle = 0x0012

motion_data_handle_uuid = "00e00000-0001-11e1-ac36-0002a5d5c51b"

motion_data_handle = 0x0011


# Solution from: https://stackoverflow.com/questions/14920384/stop-code-after-time-period

# Your function

def function(uuid, n):

    for i in range(10000 * n):

        device.subscribe(uuid, callback=handle_data)

        time.sleep(1)


print("starting connection")

adapter.start()

print("started")


# connect to the bluetooth device via the pygatt adapter

device = adapter.connect(YOUR_DEVICE_ADDRESS, address_type=ADDRESS_TYPE)

print("connected")


# write the value "0x0001" to the BLE handle "0x0012," which is the receiver for the SensorTile

#  to begin sending information

device.char_write_handle(motion_data_enabler_handle, bytearray([1]))

print("written")


# once this is written, the SensorTile should start sending notifications via the handle

#  "0x0011," which we are able to read by reading the log file generated by the function

# in order to read this, we using multiprocessing to start the "characteristic read" function

#  included in pygatt. We then cancel the function soon after in order to start the logging

#  while still being able to continue in the program.


# Start function as a process

p = multiprocessing.Process(target=function, name="Function", args=(motion_data_handle_uuid,3,))

p.start()

# Wait 1 second for function

time.sleep(1)

# Terminate process

p.terminate()

# Cleanup

p.join()


# open logfile for reading

filepath = 'logfile.log'

file = open(filepath, 'r+')


counter = 0


# Example logfile line:

# "Received notification on handle=0x11, value=0xb'383b13017cfe6a032a0070002a0092fe2dfe5900 - 2019-08-02 21:23:56,270"


orientation_variables = [0,0,0]


# continuously loop the SensorTile interpolation

while True:

    line = file.readline()

    if not line:

        time.sleep(0.1)

        continue

    counter += 1

    split_line = line.split()

    if split_line[0] == "Received":

        print(convert_ST_data(split_line, orientation_variables))

    else:

        print("---")


    # reset the logfile every 1000 lines to make sure it doesn't get too big

    if counter >= 1000:

        file.truncate(0)

        counter = 0
